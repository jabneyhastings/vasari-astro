---
import CmsImage from '../components/CmsImage.astro';
import { slugify } from '../utils/slugify.js';
import { createUrl } from '../utils/url.ts';

interface Project {
    title: string;
    sliderImage: string;
    heroImage: string;
}

interface Props {
    projects: Project[];
}

const { projects } = Astro.props;
---

<section class="projects-carousel">
    <div class="projects-carousel__viewport">
        <div class="projects-carousel__track" id="projectsTrack">
            {projects.map((project) => (
                <a
                    href={createUrl(`/projects/${slugify(project.title)}`)}
                    class="projects-carousel__slide"
                >
                    <div class="projects-carousel__media">
                        <CmsImage
                            src={project.sliderImage || project.heroImage}
                            alt={project.title}
                            height={500}
                            loading="lazy"
                        />
                    </div>
                </a>
            ))}
        </div>
    </div>
</section>

<style>
    .projects-carousel {
        padding: 0 2rem;
        width: 90vw;
        max-width: 1000px;
        margin: 0 auto;
    }

    .projects-carousel__viewport {
        position: relative;
        overflow: hidden;
        touch-action: pan-y pinch-zoom;
    }

    .projects-carousel__track {
        display: flex;
        gap: 4rem;
        transition: transform 1.4s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: grab;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
    }

    .projects-carousel__track:active {
        cursor: grabbing;
    }

    .projects-carousel__track.is-dragging {
        transition: none;
        cursor: grabbing;
    }

    .projects-carousel__slide {
        flex: 0 0 calc(50% - 2rem);
        display: block;
        overflow: hidden;
        text-decoration: none;
        aspect-ratio: 3 / 4;
        position: relative;
    }

    .projects-carousel__media {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #f5f5f5;
        overflow: hidden;
    }

    :global(.projects-carousel__media img) {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        transition: transform 0.6s ease;
    }

    :global(.projects-carousel__media:hover img) {
        transform: scale(1.05);
        opacity: 1;
    }

    @media (prefers-reduced-motion: reduce) {
        .projects-carousel__track {
            transition: none;
        }
    }

    @media (max-width: 768px) {
        .projects-carousel {
            padding: 3rem 1rem;
        }

        .projects-carousel__track {
            gap: 2rem;
        }

        .projects-carousel__slide {
            flex: 0 0 100%;
            aspect-ratio: 3 / 4;
        }
    }
</style>

<script>
    class ProjectsCarousel {
        constructor(root) {
            this.root = root;
            this.track = this.root.querySelector('#projectsTrack');
            this.slides = Array.from(this.root.querySelectorAll('.projects-carousel__slide'));
            this.currentIndex = this.slides.length;
            this.autoplayInterval = null;
            this.touchState = { startX: 0, currentX: 0, isDragging: false, hasMoved: false };
            this.hasDragged = false;
            this.isHovered = false;
            this.prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            if (!this.track || this.slides.length === 0) return;

            this.cloneSlides();
            this.bindEvents();
            this.updatePosition(false);
            if (!this.prefersReducedMotion) this.startAutoplay();
        }

        cloneSlides() {
            const clonesBefore = this.slides.map(slide => slide.cloneNode(true));
            const clonesAfter = this.slides.map(slide => slide.cloneNode(true));

            clonesBefore.forEach(clone => this.track.insertBefore(clone, this.track.firstChild));
            clonesAfter.forEach(clone => this.track.appendChild(clone));

            this.allSlides = Array.from(this.track.querySelectorAll('.projects-carousel__slide'));
        }

        bindEvents() {
            this.track.addEventListener('mousedown', e => this.handleDragStart(e));
            this.track.addEventListener('mousemove', e => this.handleDragMove(e));
            this.track.addEventListener('mouseup', e => this.handleDragEnd(e));
            this.track.addEventListener('mouseleave', e => this.handleDragEnd(e));

            this.track.addEventListener('touchstart', e => this.handleTouchStart(e), { passive: false });
            this.track.addEventListener('touchmove', e => this.handleTouchMove(e), { passive: false });
            this.track.addEventListener('touchend', e => this.handleTouchEnd(e));

            this.root.addEventListener('mouseenter', () => {
                this.isHovered = true;
                this.pauseAutoplay();
            });
            this.root.addEventListener('mouseleave', () => {
                this.isHovered = false;
                if (!this.touchState.isDragging) this.resumeAutoplay();
            });

            this.track.addEventListener('click', e => {
                if (this.hasDragged) e.preventDefault();
            });

            window.addEventListener('resize', () => this.handleResize());
        }

        getGapSize() {
            const gap = getComputedStyle(this.track).gap || '0px';
            return parseInt(gap, 10) || 0;
        }

        getVisibleCount() {
            return window.innerWidth <= 768 ? 1 : 2;
        }

        updatePosition(smooth = true) {
            const slideWidth = this.allSlides[0].clientWidth;
            const gapSize = this.getGapSize();
            const offset = this.currentIndex * (slideWidth + gapSize);

            if (!smooth || this.prefersReducedMotion) this.track.style.transition = 'none';
            this.track.style.transform = `translateX(-${offset}px)`;
            if (!smooth) requestAnimationFrame(() => (this.track.style.transition = ''));
        }

        goNext() {
            this.currentIndex++;
            this.updatePosition(true);
            this.checkLoopEdges();
        }

        goPrev() {
            this.currentIndex--;
            this.updatePosition(true);
            this.checkLoopEdges();
        }

        checkLoopEdges() {
            const total = this.allSlides.length;
            const base = this.slides.length;

            setTimeout(() => {
                if (this.currentIndex >= total - base) {
                    this.track.style.transition = 'none';
                    this.currentIndex -= base;
                    this.updatePosition(false);
                } else if (this.currentIndex < base) {
                    this.track.style.transition = 'none';
                    this.currentIndex += base;
                    this.updatePosition(false);
                }
            }, 400);
        }

        handleDragStart(e) {
            if (e.button !== 0) return;
            e.preventDefault();
            this.touchState.startX = e.clientX;
            this.touchState.currentX = e.clientX;
            this.touchState.isDragging = true;
            this.touchState.hasMoved = false;
            this.hasDragged = false;
            this.track.classList.add('is-dragging');
            this.pauseAutoplay();
            document.body.style.userSelect = 'none';
        }

        handleDragMove(e) {
            if (!this.touchState.isDragging) return;
            e.preventDefault();
            
            const diff = e.clientX - this.touchState.startX;
            
            if (Math.abs(diff) > 5) {
                this.touchState.hasMoved = true;
                this.hasDragged = true;
            }
            
            const slideWidth = this.allSlides[0].clientWidth;
            const gapSize = this.getGapSize();
            const baseOffset = this.currentIndex * (slideWidth + gapSize);
            this.track.style.transition = 'none';
            this.track.style.transform = `translateX(-${baseOffset - diff}px)`;
        }

        handleDragEnd(e) {
            if (!this.touchState.isDragging) return;
            this.track.classList.remove('is-dragging');
            document.body.style.userSelect = '';
            
            const diff = e.clientX - this.touchState.startX;
            const threshold = 80;

            this.track.style.transition = '';

            if (Math.abs(diff) > threshold) {
                diff > 0 ? this.goPrev() : this.goNext();
            } else if (this.touchState.hasMoved) {
                this.updatePosition(true);
            }

            this.touchState.isDragging = false;
            this.touchState.hasMoved = false;
            
            setTimeout(() => {
                this.hasDragged = false;
            }, 10);
            
            if (!this.isHovered) this.resumeAutoplay();
        }

        handleTouchStart(e) {
            const touch = e.touches[0];
            this.touchState.startX = touch.clientX;
            this.touchState.currentX = touch.clientX;
            this.touchState.isDragging = true;
            this.touchState.hasMoved = false;
            this.hasDragged = false;
            this.track.classList.add('is-dragging');
            this.pauseAutoplay();
        }

        handleTouchMove(e) {
            if (!this.touchState.isDragging) return;
            const touch = e.touches[0];
            const diff = touch.clientX - this.touchState.startX;
            
            if (Math.abs(diff) > 5) {
                this.touchState.hasMoved = true;
                this.hasDragged = true;
                e.preventDefault();
            }
            
            this.touchState.currentX = touch.clientX;
            const slideWidth = this.allSlides[0].clientWidth;
            const gapSize = this.getGapSize();
            const baseOffset = this.currentIndex * (slideWidth + gapSize);
            this.track.style.transition = 'none';
            this.track.style.transform = `translateX(-${baseOffset - diff}px)`;
        }

        handleTouchEnd() {
            if (!this.touchState.isDragging) return;
            this.track.classList.remove('is-dragging');
            
            const diff = this.touchState.currentX - this.touchState.startX;
            const threshold = 80;

            this.track.style.transition = '';

            if (Math.abs(diff) > threshold) {
                diff > 0 ? this.goPrev() : this.goNext();
            } else if (this.touchState.hasMoved) {
                this.updatePosition(true);
            }

            this.touchState.isDragging = false;
            this.touchState.hasMoved = false;
            
            setTimeout(() => {
                this.hasDragged = false;
            }, 10);
            
            this.resumeAutoplay();
        }

        handleResize() {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => this.updatePosition(false), 150);
        }

        startAutoplay() {
            this.autoplayInterval = setInterval(() => {
                if (!this.touchState.isDragging && !this.isHovered) this.goNext();
            }, 3000);
        }

        pauseAutoplay() {
            clearInterval(this.autoplayInterval);
            this.autoplayInterval = null;
        }

        resumeAutoplay() {
            if (!this.prefersReducedMotion && !this.autoplayInterval) this.startAutoplay();
        }

        destroy() {
            this.pauseAutoplay();
        }
    }

    let carouselInstance = null;

    const initializeCarousel = () => {
        const root = document.querySelector('.projects-carousel');
        if (root) carouselInstance = new ProjectsCarousel(root);
    };

    const destroyCarousel = () => {
        if (carouselInstance) carouselInstance.destroy();
        carouselInstance = null;
    };

    document.addEventListener('astro:page-load', initializeCarousel);
    document.addEventListener('astro:before-swap', destroyCarousel);
</script>